#Added ball physics that interact with walls, but not paddles yet.  Press k to begin ball movement.  
#Change the initial ball trajectory from 180 to something else by changing the initial_ball_angle variable to the desired angle.
#Paddle interaction and lose detection (teleports ball back to middle) now complete, Pong template complete. (1/4/2019)

import pygame, time, sys, random, math

WHITE = (255, 255, 255)

pygame.init()
screen = pygame.display.set_mode((1300,600))
pygame.display.set_caption('Escalate')

moving = 1
initial_ball_angle = 180
ball_rad = 10
ball_speed = 1.5

player_width = 20
player_length = 100


def angle_math(angle):
    core = angle

    if core in range(91):
        difference = (90 - core) * 2
        return int(difference)

    elif core in range(90, 181):
        difference2 = (180 - core) * 2
        return int(difference2)

    elif core in range(180, 271):
        difference3 = (270 - core) * 2
        return int(difference3)

    elif core in range(270, 361):
        difference4 = (360 - core) * 2
        return int(difference4)


class Player1:
    def __init__(self, x, y, r, g, b, width, height, w, spd):
        self.x = x
        self.y = y
        self.r = r
        self.g = g
        self.b = b
        self.width = width
        self.height = height
        self.w = w
        self.spd = spd

    def display_p(self):

        pygame.draw.rect(screen, (self.r, self.g, self.b), (int(self.x), int(self.y), self.width, self.height), self.w)

    def move(self):
        key = pygame.key
        pygame.event.pump()

        if key.get_pressed()[pygame.K_a] and self.y > 0:
            self.y -= self.spd
        if key.get_pressed()[pygame.K_d] and self.y < 600-self.height:
            self.y += self.spd


class Player2:
    def __init__(self, x, y, r, g, b, width, height, w, spd2):
        self.x = x
        self.y = y
        self.r = r
        self.g = g
        self.b = b
        self.width = width
        self.height = height
        self.w = w
        self.spd2 = spd2

    def display_p(self):
        pygame.draw.rect(screen, (self.r, self.g, self.b), (int(self.x), int(self.y), self.width, self.height), self.w)

    def move(self):
        key = pygame.key
        pygame.event.pump()

        if key.get_pressed()[pygame.K_RIGHT] and self.y > 0:
            self.y -= self.spd2
        if key.get_pressed()[pygame.K_LEFT] and self.y < 600-self.height:
            self.y += self.spd2


player_list = []
PL1 = Player1(0, 300, 0, 0, 255, player_width, player_length, 0, 2)
PL2 = Player2(1280, 300, 0, 0, 255, player_width, player_length, 0, 2)
player_list.append(PL1)
player_list.append(PL2)

transfer_x1 = PL1.x
transfer_y1 = PL1.y
transfer_x2 = PL2.x
transfer_y2 = PL2.y


class MainBall:
    def __init__(self, x11, y11, r, g, b, ra, w, angle, spd2):
        self.x11 = x11
        self.y11 = y11
        self.r = r
        self.g = g
        self.b = b
        self.ra = ra
        self.w = w
        self.angle = angle
        self.spd2 = spd2

    def display_circle(self):
        pygame.draw.circle(screen, (self.r, self.g, self.b), (int(self.x11), int(self.y11)), self.ra, self.w)

    def move_circle(self, Player1, Player2):
        global moving, player_length, ball_rad
        key = pygame.key
        pygame.event.pump()

        inst_x1 = Player1.x
        inst_y1 = Player1.y
        inst_x2 = Player2.x
        inst_y2 = Player2.y

        middle1 = inst_y1 + 50
        middle2 = inst_y2 + 50

        # -moving toggle ---

        if moving == 2:
            if key.get_pressed()[pygame.K_i]:
                moving -= 1
        if moving == 1:
            if key.get_pressed()[pygame.K_k]:
                moving += 1

        # --------

        # -angle bounce physics ---

        if self.angle > 360:
            self.angle = self.angle % 360

        # -for walls
        if self.y11-ball_rad < 0 or self.y11+ball_rad > 600:
            ang = angle_math(self.angle)
            self.angle += ang + 180

        if self.x11 - ball_rad < 0 or self.x11 + ball_rad > 1300:
            self.x11 = self.x11 - self.x11 + 650
            self.y11 = self.y11 - self.y11 + 300
            if self.angle <= 90 or self.angle >= 270:
                self.angle = 0
            if self.angle >= 180 and self.angle <= 360:
                self.angle = 180

        # ---

        # -for paddles
        if self.x11-ball_rad < 20 and self.y11 + ball_rad > inst_y1 and self.y11 - ball_rad < inst_y1 + 100:
            ang = angle_math(self.angle)
            self.angle += ang + 180 - (math.sqrt((int(self.y11)-middle1)**2))

        if self.x11+ball_rad > 1280 and self.y11 + ball_rad > inst_y2 and self.y11 - ball_rad < inst_y2 + 100:
            ang = angle_math(self.angle)
            self.angle += ang + 180 - (math.sqrt((int(self.y11)-middle2)**2))

        # ---

        angle1 = math.radians(self.angle)

        # --------

        # -ball moving math ---

        if moving == 2:
            self.x11 += math.cos(angle1) * self.spd2
            self.y11 -= math.sin(angle1) * self.spd2

        # -------


ball = MainBall(650, 300, 0, 150, 200, ball_rad, 0, initial_ball_angle, ball_speed)


pygame.display.flip()

while 1:

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

    screen.fill(WHITE)
    for player in player_list:
        player.display_p()
        player.move()

    ball.display_circle()
    ball.move_circle(PL1, PL2)

    pygame.display.update()
